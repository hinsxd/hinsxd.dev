---
title: Learning notes - Jumping from TypeScript to Golang
date: "2023-10-02"
tags: ["golang", "typescript", "learning-notes"]
draft: false
summary: Golang learning notes by a typescript wizard. Tears and blood.
---

# Background

Recently, I decided to revamp my personal game tracking website [Chu2track](https://chu2track.hinsxd.dev).
The old stack was Next.js 12, MongoDB, Type-Graphql in api routes.
I was quite happy with the stack, but I found that GraphQL can be really hard to scale.
While frontend devs can happily query whatever they want, backend devs have to be careful about the queries, otherwise it can be a huge performance issue.

Also, I did not use the [Relay spec](https://relay.dev/docs/guides/graphql-server-specification/)
when defining the schemas and resolvers, making it even harder to implement paginations and connections.
(I can talk about the wrong design decisions for hours, but let's save it for another day).

Anyways, then I thought, why not try something new? Golang has been a hot topic for a while, and I have been wanting to learn it for a long time.
My co-workers have been using it in the past years and I notice the great performance it provided.
Frankly speaking, their API didn't provide the best DX, but I think I can learn from their mistakes and make it better.

As a result, Chu2track will be the first project I use Golang in production (some day).
I will probably write another post about how I choose the tools to satisfy my needs, but for now, let's focus on the language itself.
In this post, I will be including many links to the official documentation, so you can read more about the topics that interest you.

# Learning notes

# 1. Types and Variables

If you're same as me, a typescript wizard, you might find Golang a bit weird at first.

Similar to Typescript, Golang is a statically typed language.
However, compiling and type checking Typescript code is two separate steps, one can ignore all the type errors and still get a compiled Javascript code.

On the other hand, Golang will not compile if there are any type errors, and types are not just for the compiler, they are also for the runtime.
So Golang forces you to write code that is more type-safe, which is a good thing.

## 1.1 Variable Declaration, Initialization and Assignment

There are three ways to declare a variable in Golang.

```go
// 1. Declare with type and initialize
var a int = 1
var b, c int = 1, 2

// 2. Declare and initialize with type inference
var a = 1 // a is of type int
var b, c = 1, 2 // b and c are of type int

// 3. Declare and initialize with short variable declaration
a := 1 // a is of type int
b, c := 1, 2 // b and c are of type int
```

Multiple assignment might not seem useful at first, but it is actually quite useful when you want to swap two variables.

```go
var a int = 1
var b int = 2

a, b = b, a // a is now 2, b is now 1
```

It is also useful when you want to return multiple values from a function.

```go
func swap(a int, b int) (int, int) {
  return b, a
}

var a int = 1
var b int = 2

a, b = swap(a, b) // a is now 2, b is now 1
```

Many functions in Golang return multiple values, so you will see this pattern a lot. We can also discard the values we don't need by using the blank identifier `_`.

```go
a, _ = swap(a, b) // a is now 2, and I don't care about the second value
```

### Short variable declaration VS `var`

Although short variable declaration is the most concise way, you can only use it inside a function, and you must also assign a value to the variable at declaration.

`var` gives more control over the variable, so you can declare a variable without initializing it, and you can also declare multiple variables at once.

```go
// Declare without initializing
var a int
// ... later in code
a = 1

// Grouping with var
var (
  a int
  b int
)
```

### **Must know: The zero value** ([Docs](https://golang.org/ref/spec#The_zero_value))

In Golang, variables are always initialized to a zero value, which is a default value for the type.
For example, the zero value for `int` is `0`, and the zero value for `string` is `""`.

```go
var a int // a is now 0
var b string // b is now ""
```

## 1.2 Constants

Constants are variables whose values cannot be changed after initialization.
The syntax for declaring constants is similar to variables, but you use the `const` keyword instead of `var`.
Also, you must initialize a constant at declaration, and you cannot use the short **_variable_** declaration syntax.

```go
const a int64 = 1
const b = 1 // a is of type int
```

## 1.3 Types in Golang ([Docs](https://golang.org/ref/spec#Types))

### 1.3.1 Boolean

```go
// Boolean
var isTrue bool = true
```

### 1.3.2 Numeric

```go
// Numeric
var int_num int = 1

var int8_num int8 = 1
var int16_num int16 = 1
var int32_num int32 = 1
var int64_num int64 = 1

var uint_num uint = 1

var uint8_num uint8 = 1
var uint16_num uint16 = 1
var uint32_num uint32 = 1
var uint64_num uint64 = 1

var float32_num float32 = 1.0
var float64_num float64 = 1.0

// Complex
var complex64_num complex64 = 1 + 1i
var complex128_num complex128 = 1 + 1i

// Byte (alias for uint8)
var byte_value byte = 1
```

As you can see, Golang has a lot of numeric types, and it can be confusing at first.
The reason for having so many numeric types is to provide more control over the memory usage.
For example, if you know that a variable will never be larger than 255, you can use `uint8` instead of `uint64` to save memory.

One thing to note is that `int` and `uint` are platform dependent, which means that they can be either 32-bit or 64-bit.
If the go compiler is running on a 32-bit machine, `int` and `uint` will be 32-bit, otherwise they will be 64-bit.

Also, Golang has two types for representing numbers with decimal points, `float32` and `float64`.
The reason for having two types is that `float32` is more performant than `float64`, but it is less precise.
So if you need to do precise calculations, you should use `float64`.

### 1.3.3 String and rune ([Docs](https://golang.org/ref/spec#String_types)) ([Go blog](https://go.dev/blog/strings))

```go
// String
var str string = "Hello World"
// Rune
var rune_value rune = 'a'
```

In Go, a string is a read-only slice (just treat it as array first, we will come back to it later) of bytes, and a rune (single character) is an alias for `int32`.
Strings must be quoted with double quotes `"`, and runes must be quoted with single quotes `'`.

### 1.3.4 Array and slices ([Docs](https://golang.org/ref/spec#Array_types)) ([Go Blog](https://go.dev/blog/slices-intro))

#### Arrays

An array is a fixed-length sequence of elements of a single type. The zero value of an array is an array with all elements set to their zero value.

Arrays can be defined like this:

```go
// 1. Define with type and length
var arr [3]int // arr is now [0, 0, 0]

// 2. Define with type, length and initialize
var arr [3]int = [3]int{1, 2, 3} // arr is now [1, 2, 3]

// Unfilled elements will be initialized to zero value
var arr [3]int = [3]int{1, 2} // arr is now [1, 2, 0]

// 3. Define with type, length and initialize (short syntax)
var arr = [3]int{1, 2, 3} // arr is now [1, 2, 3]

// 4. Define with type, length and initialize (short syntax)
arr := [3]int{1, 2, 3} // arr is now [1, 2, 0]

// 5. Define with type and initialize, the length will be determined by the number of elements
arr := [...]int{1, 2, 3} // arr is now [1, 2, 3]
```

#### Slices

Slices are much more common than arrays in Golang, and they are more flexible than arrays.

Slices can be defined like arrays, but without the length. The zero value of a slice is `nil`.

```go
// 1. Define with type and initialize
var slice []int = []int{1, 2, 3} // slice is now [1, 2, 3]

// 2. Define with type and initialize (short syntax)
slice := []int{1, 2, 3} // slice is now [1, 2, 3]

// 3. Uninitialized slice
var slice []int // slice is now nil
fmt.Println(slice == nil) // true
fmt.Println(slice) // still gives [], but it IS nil
```

Slices can also be created from "slicing" an array or another slice.

```go
var arr = [3]int{1, 2, 3}
var slice = arr[0:2] // slice is now [1, 2]

var slice = []int{1, 2, 3, 4}
var slice2 = slice[1:] // slice2 is now [2, 3, 4]
```

#### Relationship between arrays and slices, capacity and length

Every slice has an underlying array, and the slice is like a "View" into the array.
When you slice an array or a slice, you are creating a new slice that points to the same underlying array.
Therefore, if you change the value of an element in the array, the value of the element in the slice will also change.

```go
var arr = [3]int{1, 2, 3}
var slice = arr[1:] // slice is now [2, 3]

slice[1] = 4
fmt.Println(arr) // arr is now [1, 2, 4]
fmt.Println(slice) // slice is now [2, 4]
```

The length of a slice is always less than or equal to the length of the underlying array.

Consider the following:

```go
var arr = [6]string{"g", "o", "l", "a", "n", "g"}
var slice = arr[2:4] // slice is now ["l", "a"]

fmt.Println(len(slice)) // 2
fmt.Println(cap(slice)) // 4
```

As the slice current contains 2 elements, the length of `slice` is 2.

The capacity of `slice` is 4 because the length of the underlying array is 6, and the slice starts at index 2, the slice window can expand to index 5, including at most 4 elements.

#### Appending to slices

You can append elements to a slice using the `append` function.

```go
var slice = []int{1, 2, 3}
slice = append(slice, 4) // slice is now [1, 2, 3, 4]
```

As the slice is linked to the underlying array, if the array is full, `append` will create a new array and copy the elements to the new array.
Otherwise, it will just expend the "view" of the slice and overwrite the value of the element in the underlying array.

```go
var arr = [4]int{1, 2, 3, 4}
var slice = arr[0:3] // slice is now [1, 2, 3]
fmt.Println(len(slice)) // 3

slice = append(slice, 5) // slice is now [1, 2, 3, 5]
fmt.Println(len(slice)) // 4
fmt.Println(arr) // arr is now [1, 2, 3, 5], "4" is replaced by "5"

// At this point, the slice is full because the right index of the slice reaches the end of the underlying array
slice = append(slice, 6) // slice is now [1, 2, 3, 4, 5, 6]
// Golang will create a new array and copy the elements to the new array
fmt.Println(arr) // arr is still [1, 2, 3, 5], "6" is not appended to the array.
```

### 1.3.5 Structs ([Docs](https://golang.org/ref/spec#Struct_types))

Structs are similar to objects/classes in Typescript, used to group related data together.

```go
type Person struct {
  name string
  age int
}

// Using positional arguments
var persion1 Person = Person{"hinsxd", 18}

// Using named arguments
var person2 Person = Person{
  name: "hinsxd",
  age: 18,
}
```

When using named arguments, all unfilled fields will be initialized to their zero value.
When using positional arguments, you must provide all fields in the struct.

```go
type Person struct {
  name string
  age int
}

var person Person = Person{
  name: "hinsxd",
}
fmt.Println(person) // {hinsxd 0}

// You can also use positional arguments
var person2 Person = Person{"hinsxd"} // Error: too few values in struct initializer
var person2 Person = Person{"hinsxd", 18} // OK
```

We should always use named arguments when initializing structs, as it is more readable and less error-prone.
If we use positional arguments, we might accidentally swap the order of the arguments, and either leading to a bug or making the compiler complain.

## 1.4 Type conversion

Golang is a statically typed language, so you cannot convert a variable to another type without explicitly telling the compiler.

```go
var a int = 1
var b int64 = 1

// This will not compile
a = b
```

To convert a variable to another type, you can use the following syntax: `T(x)`, where `T` is the type you want to convert to, and `x` is the variable you want to convert.

We should note that only convert a variable `x` to a type `T` if `x` is representable by a value of `T` (Read more: [Representability](https://go.dev/ref/spec#Representability))

There are less magical conversions (type coercions) in Golang than in Typescript, so you have to be careful when converting types.

```go
var a int = 1
var b int64 = 1

// This will compile
var c int = int(b)

// This will not compile
var d bool = bool(a) // Error: cannot convert a (variable of type int) to type bool
```

Type conversion does not work on slice/array types. You have to copy the elements to a new slice/array using loops.

```go
var arr = []int{1, 2, 3}
var arr2 = ([]int64)(arr) // Error: cannot convert arr (variable of type []int) to type []int64

var arrInt64 [3]int64
for i, v := range arr {
  // Convert each element to int64
  arrInt64[i] = int64(v)
}
```
